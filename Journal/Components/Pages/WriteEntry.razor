@page "/write-entry"
@implements IDisposable
@using JournalApp.Services
@using JournalApp.Models
@using Microsoft.JSInterop
@inject IJSRuntime JS
@inject JournalService JournalService
@inject MoodService MoodService
@inject TagService TagService
@inject NavigationManager Navigation

<div style="max-width: 800px; margin: 0 auto; padding: 1rem;">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h3 class="mb-0">Daily Journal</h3>
        <div>
            <button class="btn btn-outline-secondary btn-sm" @onclick="BackToEntries" disabled="@isSaving || isProcessing">← Back to All Entries</button>
            <button class="btn btn-outline-primary btn-sm ms-2" @onclick="ExportEntry" disabled="@entry == null">Export</button>
        </div>
    </div>

    @if (isLoading)
    {
        <div class="text-center py-5">
            <div class="spinner-border" role="status" aria-hidden="true"></div>
            <div class="mt-2 text-muted">Loading...</div>
        </div>
    }
    else if (entry == null)
    {
        <div class="empty-state p-4 text-center border-dashed rounded-2">
            <p class="text-muted">No entry yet.</p>
            <button class="btn btn-primary mt-2" @onclick="CreateEntry" disabled="@isSaving">Start Writing</button>
        </div>
    }
    else
    {
        <EditForm Model="entry" OnValidSubmit="Save">
            <div class="card">
                <div class="card-header bg-light">
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <strong>@entry.Date.ToString("dddd, MMMM dd, yyyy")</strong>
                            @if (entry.UpdatedAt != default)
                            {
                                <div class="small text-muted">Last saved: @entry.UpdatedAt.ToString("g")</div>
                            }
                        </div>
                        <div class="text-end">
                            @if (isAutosaving)
                            {
                                <small class="text-muted">Autosaving…</small>
                            }
                        </div>
                    </div>
                </div>

                <div class="card-body">
                    <ValidationSummary />

                    <!-- Title -->
                    <div class="mb-3">
                        <label for="titleInput" class="form-label">Title <span class="text-muted small">(required)</span></label>
                        <InputText id="titleInput" class="form-control" @bind-Value="entry.Title" placeholder="Enter a title" maxlength="200" />
                    </div>

                    <!-- Mood -->
                    <div class="mb-3">
                        <label class="form-label">How are you feeling today? <span class="text-muted small">(required)</span></label>
                        <InputSelect class="form-select" @bind-Value="selectedPrimaryMood" aria-label="Primary mood">
                            <option value="">— Select Primary Mood —</option>
                            @foreach (var mood in primaryMoods)
                            {
                                <option value="@mood.Name">@mood.Name (@mood.MoodType)</option>
                            }
                        </InputSelect>

                        <div class="mt-2">
                            <label class="form-label">Secondary Moods (optional, up to 2)</label>
                            <div class="d-flex gap-2">
                                <InputSelect class="form-select" @bind-Value="selectedSecondaryMood1">
                                    <option value="">Select</option>
                                    @foreach (var mood in secondaryMoods.Where(m => m.Name != selectedPrimaryMood))
                                    {
                                        <option value="@mood.Name">@mood.Name (@mood.MoodType)</option>
                                    }
                                </InputSelect>

                                <InputSelect class="form-select" @bind-Value="selectedSecondaryMood2">
                                    <option value="">Select</option>
                                    @foreach (var mood in secondaryMoods.Where(m => m.Name != selectedPrimaryMood && m.Name != selectedSecondaryMood1))
                                    {
                                        <option value="@mood.Name">@mood.Name (@mood.MoodType)</option>
                                    }
                                </InputSelect>
                            </div>
                        </div>
                    </div>

                    <!-- Content with Quill Editor -->
                    <div class="mb-3">
                        <label class="form-label">Your thoughts for today <span class="text-muted small">(required)</span></label>
                        <div id="quill-editor" style="height: 300px; background: white; border: 1px solid #dee2e6; border-radius: 0.375rem;"></div>
                        <div class="form-text text-muted mt-1">Tip: Use Ctrl+S to save.</div>
                    </div>

                    <!-- Tags -->
                    <div class="mb-3">
                        <label class="form-label">Tags</label>
                        <input class="form-control" @bind="selectedTags" placeholder="work, personal, goals" />
                        @if (!string.IsNullOrWhiteSpace(selectedTags))
                        {
                            <div class="selected-tags mt-2">
                                <small class="text-muted">Tags: @string.Join(", ", selectedTags.Split(',').Where(t => !string.IsNullOrWhiteSpace(t)).Select(t => t.Trim()))</small>
                            </div>
                        }

                        @if (allTags != null && allTags.Any())
                        {
                            <div class="mt-2">
                                <small class="text-muted">Suggestions:</small>
                                <div class="d-flex flex-wrap gap-2 mt-1">
                                    @foreach (var t in allTags)
                                    {
                                        <button type="button" class="btn btn-sm btn-outline-secondary" @onclick="() => AddTagSuggestion(t.Name ?? string.Empty)">@t.Name</button>
                                    }
                                </div>
                            </div>
                        }
                    </div>

                    <!-- Actions -->
                    <div class="d-flex justify-content-end gap-2">
                        @if (isEditing)
                        {
                            <button type="button" class="btn btn-outline-danger" @onclick="PromptDelete" disabled="@isSaving || isProcessing">Delete</button>
                        }

                        <button type="button" class="btn btn-outline-secondary" @onclick="BackToEntries" disabled="@isSaving || isProcessing">Cancel</button>

                        <button type="submit" class="btn btn-success" disabled="@isSaving || isProcessing">
                            @if (isSaving)
                            {
                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                <span class="ms-1">Saving…</span>
                            }
                            else
                            {
                                <span>Save</span>
                            }
                        </button>
                    </div>
                </div>
            </div>
        </EditForm>

        @if (!string.IsNullOrEmpty(statusMessage))
        {
            <div class="alert alert-info mt-3">@statusMessage</div>
        }
    }
</div>

@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger toast-position" role="alert" @onclick="ClearError">
        <div class="d-flex">
            <div>@errorMessage</div>
            <button type="button" class="btn-close ms-auto" aria-label="Close" @onclick="ClearError"></button>
        </div>
    </div>
}

@if (!string.IsNullOrEmpty(successMessage))
{
    <div class="alert alert-success toast-position" role="status" @onclick="ClearSuccess">
        <div class="d-flex">
            <div>@successMessage</div>
            <button type="button" class="btn-close ms-auto" aria-label="Close" @onclick="ClearSuccess"></button>
        </div>
    </div>
}

<!-- Delete confirmation modal -->
@if (showDeleteConfirm)
{
    <div class="modal-backdrop d-block" style="background-color: rgba(0,0,0,0.5);">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Confirm delete</h5>
                    <button type="button" class="btn-close" aria-label="Close" @onclick="CloseDelete" disabled="@isProcessing"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete the entry "<strong>@entry?.Title</strong>"? This action cannot be undone.</p>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" @onclick="CloseDelete" disabled="@isProcessing">Cancel</button>
                    <button class="btn btn-danger" @onclick="Delete" disabled="@isProcessing">
                        @if (isProcessing)
                        {
                            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                        }
                        <span class="ms-1">Delete</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
}

<!-- Unsaved changes confirm -->
@if (showUnsavedConfirm)
{
    <div class="modal-backdrop d-block" style="background-color: rgba(0,0,0,0.5);">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Unsaved changes</h5>
                    <button type="button" class="btn-close" aria-label="Close" @onclick="CancelUnsavedNavigation" disabled="@isProcessing"></button>
                </div>
                <div class="modal-body">
                    <p>You have unsaved changes. Do you want to leave without saving?</p>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" @onclick="CancelUnsavedNavigation" disabled="@isProcessing">Stay</button>
                    <button class="btn btn-danger" @onclick="ConfirmUnsavedNavigation" disabled="@isProcessing">Leave</button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public int? EntryId { get; set; }

    private JournalEntry? entry;
    private bool isInitialized = false;
    private bool isLoading = true;
    private bool isSaving = false;
    private bool isProcessing = false;
    private bool isAutosaving = false;
    private bool isEditing = false;
    private bool isDisposed = false;

    private List<Mood> primaryMoods = new();
    private List<Mood> secondaryMoods = new();
    private List<Tag> allTags = new();

    private string selectedPrimaryMood = "";
    private string selectedSecondaryMood1 = "";
    private string selectedSecondaryMood2 = "";
    private string selectedTags = "";

    private string statusMessage = "";
    private string errorMessage = "";
    private string successMessage = "";

    private DotNetObjectReference<WriteEntry>? dotNetRef;
    private CancellationTokenSource? autosaveCts;
    private CancellationTokenSource? saveCts;

    private bool unsavedChanges = false;
    private bool showDeleteConfirm = false;
    private bool showUnsavedConfirm = false;
    private string? pendingNavigationTarget = null;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await LoadMoodsAndTags();
            await LoadEntry();

            // Create dotnet ref for JS callbacks (keyboard shortcut, editor change)
            dotNetRef = DotNetObjectReference.Create(this);

            // Register beforeunload to warn user on page refresh/close when there are unsaved changes
            await JS.InvokeVoidAsync("registerBeforeUnload", dotNetRef);

        }
        catch (Exception ex)
        {
            errorMessage = $"Initialization error: {ex.Message}";
            Console.Error.WriteLine(ex);
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task LoadMoodsAndTags()
    {
        try
        {
            primaryMoods = await MoodService.GetMoodsByCategoryAsync("Primary");
            secondaryMoods = await MoodService.GetMoodsByCategoryAsync("Secondary");
            allTags = await TagService.GetAllTagsAsync();
        }
        catch (Exception ex)
        {
            errorMessage = $"Error loading moods or tags: {ex.Message}";
            Console.Error.WriteLine(ex);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (isDisposed) return;

        if (entry != null && !isInitialized)
        {
            try
            {
                // Give small delay for rendering
                await Task.Delay(50);

                // Initialize Quill editor and wire up change events and keyboard shortcuts
                await JS.InvokeVoidAsync("initQuillEditor", "quill-editor", dotNetRef);

                if (!string.IsNullOrWhiteSpace(entry.Content))
                {
                    await JS.InvokeVoidAsync("setQuillContent", entry.Content);
                }

                // Register Ctrl+S shortcut in JS that will call dotnet SaveShortcut
                await JS.InvokeVoidAsync("registerEditorShortcuts", dotNetRef);

                isInitialized = true;
            }
            catch (Exception ex)
            {
                errorMessage = $"Editor initialization failed: {ex.Message}";
                Console.Error.WriteLine(ex);
            }
        }
    }

    private async Task LoadEntry()
    {
        try
        {
            isLoading = true;
            if (EntryId.HasValue && EntryId.Value > 0)
            {
                entry = await JournalService.GetEntryAsync(EntryId.Value);
                if (entry == null)
                {
                    errorMessage = "Entry not found.";
                }
                else
                {
                    isEditing = true;
                    selectedPrimaryMood = entry.PrimaryMood ?? "";
                    selectedSecondaryMood1 = entry.SecondaryMoods?.Split(',').FirstOrDefault()?.Trim() ?? "";
                    selectedSecondaryMood2 = entry.SecondaryMoods?.Split(',').Skip(1).FirstOrDefault()?.Trim() ?? "";
                    selectedTags = entry.Tags ?? "";
                }
            }
            else
            {
                // New entry
                entry = new JournalEntry
                {
                    Date = DateTime.Today,
                    CreatedAt = DateTime.Now,
                    UpdatedAt = DateTime.Now
                };
                isEditing = false;
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error loading entry: {ex.Message}";
            Console.Error.WriteLine(ex);
        }
        finally
        {
            isLoading = false;
        }
    }

    private void CreateEntry()
    {
        entry = new JournalEntry
        {
            Date = DateTime.Today,
            CreatedAt = DateTime.Now,
            UpdatedAt = DateTime.Now
        };
        selectedPrimaryMood = "";
        selectedSecondaryMood1 = "";
        selectedSecondaryMood2 = "";
        selectedTags = "";
        isEditing = false;
        statusMessage = "Creating new entry.";
        StateHasChanged();
    }

    // Called from JS when editor text changes - we debounce autosave here
    [JSInvokable]
    public async Task OnQuillTextChanged()
    {
        if (entry == null) return;

        // Read current editor content
        try
        {
            var content = await JS.InvokeAsync<string>("getQuillContent");
            entry.Content = content;
            unsavedChanges = true;

            DebounceAutoSave();
            StateHasChanged();
        }
        catch
        {
            // swallow - non-critical
        }
    }

    private void DebounceAutoSave()
    {
        try
        {
            autosaveCts?.Cancel();
            autosaveCts = new CancellationTokenSource();
            var token = autosaveCts.Token;

            _ = Task.Run(async () =>
            {
                try
                {
                    await Task.Delay(1500, token); // 1.5s debounce
                    if (token.IsCancellationRequested) return;

                    await InvokeAsync(AutoSave);
                }
                catch (TaskCanceledException) { }
                catch (Exception ex)
                {
                    Console.Error.WriteLine($"Autosave error: {ex}");
                }
            }, token);
        }
        catch { }
    }

    private async Task AutoSave()
    {
        if (entry == null) return;

        try
        {
            isAutosaving = true;
            // Minimal validations for autosave: we allow saving content even if title empty
            entry.PrimaryMood = selectedPrimaryMood;
            entry.SecondaryMoods = string.Join(", ", new[] { selectedSecondaryMood1, selectedSecondaryMood2 }.Where(s => !string.IsNullOrWhiteSpace(s)));
            entry.Tags = selectedTags?.Trim();

            saveCts?.Cancel();
            saveCts = new CancellationTokenSource();

            var id = await JournalService.SaveEntryAsync(entry);
            if (id > 0)
            {
                entry.Id = id;
                entry.UpdatedAt = DateTime.Now;
                unsavedChanges = false;
                successMessage = "Autosaved";
                StateHasChanged();
                await Task.Delay(700);
                successMessage = "";
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"AutoSave failed: {ex}");
            // keep user informed but do not interrupt
        }
        finally
        {
            isAutosaving = false;
        }
    }

    // Triggered by Ctrl+S JS shortcut
    [JSInvokable]
    public async Task SaveShortcut()
    {
        await Save();
    }

    private async Task Save()
    {
        if (entry == null) return;

        try
        {
            errorMessage = "";
            successMessage = "";
            statusMessage = "";

            // Ensure latest editor content
            if (isInitialized)
            {
                try
                {
                    entry.Content = await JS.InvokeAsync<string>("getQuillContent");
                }
                catch (Exception ex)
                {
                    errorMessage = $"Failed to read editor content: {ex.Message}";
                    return;
                }
            }

            // Basic validation
            if (string.IsNullOrWhiteSpace(entry.Title))
            {
                errorMessage = "Please enter a title.";
                return;
            }

            if (string.IsNullOrWhiteSpace(selectedPrimaryMood))
            {
                errorMessage = "Please select your primary mood.";
                return;
            }

            if (string.IsNullOrWhiteSpace(entry.Content))
            {
                errorMessage = "Please write some content.";
                return;
            }

            isSaving = true;
            entry.PrimaryMood = selectedPrimaryMood;
            entry.SecondaryMoods = string.Join(", ", new[] { selectedSecondaryMood1, selectedSecondaryMood2 }.Where(s => !string.IsNullOrWhiteSpace(s)));
            entry.Tags = selectedTags?.Trim();
            entry.UpdatedAt = DateTime.Now;

            saveCts?.Cancel();
            saveCts = new CancellationTokenSource();

            var resultId = await JournalService.SaveEntryAsync(entry);
            if (resultId > 0)
            {
                entry.Id = resultId;
                isEditing = true;
                unsavedChanges = false;
                successMessage = "Entry saved successfully!";
                StateHasChanged();

                // Short delay so user sees confirmation, then navigate back (optional)
                await Task.Delay(800);
                Navigation.NavigateTo("/entries");
            }
            else
            {
                errorMessage = "Failed to save entry.";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error saving entry: {ex.Message}";
            Console.Error.WriteLine(ex);
        }
        finally
        {
            isSaving = false;
        }
    }

    private async Task Delete()
    {
        if (entry == null || entry.Id == 0) return;

        try
        {
            isProcessing = true;
            await JournalService.DeleteEntryAsync(entry);
            successMessage = "Entry deleted.";
            unsavedChanges = false;
            showDeleteConfirm = false;
            await Task.Delay(600);
            Navigation.NavigateTo("/entries");
        }
        catch (Exception ex)
        {
            errorMessage = $"Error deleting entry: {ex.Message}";
            Console.Error.WriteLine(ex);
        }
        finally
        {
            isProcessing = false;
        }
    }

    private void PromptDelete()
    {
        showDeleteConfirm = true;
    }

    private void CloseDelete()
    {
        showDeleteConfirm = false;
    }

    private void BackToEntries()
    {
        if (unsavedChanges)
        {
            // Show modal asking whether to leave without saving
            pendingNavigationTarget = "/entries";
            showUnsavedConfirm = true;
        }
        else
        {
            Navigation.NavigateTo("/entries");
        }
    }

    private void CancelUnsavedNavigation()
    {
        pendingNavigationTarget = null;
        showUnsavedConfirm = false;
    }

    private void ConfirmUnsavedNavigation()
    {
        showUnsavedConfirm = false;
        var target = pendingNavigationTarget ?? "/entries";
        pendingNavigationTarget = null;
        unsavedChanges = false;
        Navigation.NavigateTo(target);
    }

    private void ClearError()
    {
        errorMessage = "";
    }

    private void ClearSuccess()
    {
        successMessage = "";
    }

    private async Task ExportEntry()
    {
        try
        {
            if (entry == null) return;

            var html = $"<html><head><meta charset=\"utf-8\"><title>{System.Net.WebUtility.HtmlEncode(entry.Title)}</title></head><body>" +
                       $"<h1>{System.Net.WebUtility.HtmlEncode(entry.Title)}</h1>" +
                       $"<p><em>{entry.Date:dddd, MMMM dd, yyyy}</em></p>" +
                       $"<p><strong>Mood:</strong> {System.Net.WebUtility.HtmlEncode(entry.PrimaryMood)}" +
                       (!string.IsNullOrWhiteSpace(entry.SecondaryMoods) ? $" (Secondary: {System.Net.WebUtility.HtmlEncode(entry.SecondaryMoods)})" : "") +
                       $"</p><hr/>{entry.Content}</body></html>";

            var filename = $"journal-{entry.Date:yyyy-MM-dd}.html";
            await JS.InvokeVoidAsync("downloadFile", filename, html, "text/html");
        }
        catch (Exception ex)
        {
            errorMessage = $"Export failed: {ex.Message}";
            Console.Error.WriteLine(ex);
        }
    }

    private void AddTagSuggestion(string tag)
    {
        var list = (selectedTags ?? string.Empty).Split(',').Select(t => t.Trim()).Where(t => !string.IsNullOrWhiteSpace(t)).ToList();
        if (!list.Contains(tag, StringComparer.OrdinalIgnoreCase))
        {
            list.Add(tag);
            selectedTags = string.Join(", ", list);
            unsavedChanges = true;
            DebounceAutoSave();
        }
    }

    public void Dispose()
    {
        if (isDisposed) return;
        isDisposed = true;

        try
        {
            autosaveCts?.Cancel();
            autosaveCts?.Dispose();
            saveCts?.Cancel();
            saveCts?.Dispose();
            dotNetRef?.Dispose();

            // Unregister beforeunload handler
            _ = JS.InvokeVoidAsync("unregisterBeforeUnload");
        }
        catch { }
    }
}

<style>
    .border-dashed {
        border: 1px dashed #ccc;
    }

    .selected-tags {
        padding: 8px;
        background: #e7f3ff;
        border-radius: 4px;
        border-left: 4px solid #007bff;
    }

    .toast-position {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1200;
        min-width: 220px;
    }

    .modal-backdrop .modal-dialog {
        max-width: 540px;
        margin: 6rem auto;
    }
</style>
